

#include <xc.h>
#pragma config FOSC = HS 
#pragma config WDTE = OFF 
#pragma config PWRTE = OFF 
#pragma config BOREN = ON 
#pragma config LVP = OFF 
#pragma config CPD = OFF 
#pragma config WRT = OFF 
#pragma config CP = OFF 
#define _XTAL_FREQ 20000000 
#define I2C_BAUD_RATE 100000
// LCD Pin configuration
#define Reg_selec RB0 //H - Data Input; L - Instruction
#define Enable RB1
#define D0 RD0
#define D1 RD1
#define D2 RD2
#define D3 RD3
#define D4 RD4
#define D5 RD5
#define D6 RD6
#define D7 RD7
// Function Prototypes
void Lcd_Init(void);             // Initialize the LCD
void Lcd_Cmd(unsigned char);     // Send command to LCD
void Lcd_Clear(void);            // Clear LCD screen
void Lcd_Set_Cursor(unsigned char, unsigned char); // Set cursor position
void Lcd_Write_Char(char);       // Write a character to the LCD
void Lcd_Write_String(char*);    // Write a string to the LCD
void Lcd_Display_Hex(unsigned char hex_value);
void I2C_Init(void);
void I2C_Start(void);
void I2C_RepeatedStart(void);
void I2C_Write(unsigned char data);
unsigned char I2C_Read(void);
void I2C_Acknowledge(unsigned char ack_type);
void I2C_Stop(void);
void EEPROM_Write(unsigned char address, unsigned char data);
unsigned char EEPROM_Read(unsigned char address);
void main(void) {
    TRISB = 0x00;  // Set PORTB as output for LCD
    TRISD = 0x00;  // Set PORTB as output for LCD
    TRISC = 0x18;  // Set SCL (RC3) as input (open-drain)
    unsigned char received_data;
    Lcd_Init();  // Initialize LCD
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("I2c__EEPROM");
    for (int i = 0; i < 2; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Write_String("Let's Go....");
    for (int i = 0; i < 2; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    I2C_Init();
    EEPROM_Write(0x02, 0x42);
    received_data = EEPROM_Read(0x02);
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("THE_DATA_IS");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Write_Char(received_data);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    
    while (1) {
        // Endless loop
    }
}
// I2C Initialization function
void I2C_Init(void) {
    SSPCON = 0x28;   // Enable I2C in master mode (SSPCON1<4:3> = 10)
    SSPCON2 = 0x00;   // Clear SSPCON2 register
    SSPADD = (_XTAL_FREQ / (4 * I2C_BAUD_RATE)) - 1;  // Set baud rate for 100 kHz
  /*  Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("I2C_Init");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    } */
    
} 
void I2C_Start(void) {
  
  /*  Lcd_Set_Cursor(2, 1);  // Set cursor to first row, first column
    Lcd_Write_String("I2C_Start");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    } */
    SSPCON2bits.SEN = 1;         // Initiate Start condition
    while(SSPCON2bits.SEN);      // Wait for Start condition to complete
    PIR1bits.SSPIF = 0;   // Clear SSP interrupt flag after start condition
  /*  Lcd_Set_Cursor(2, 1); 
    Lcd_Write_String("Start_done");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    } */
}
void I2C_RepeatedStart(void) {
    
    SSPCON2bits.RSEN = 1;        // Initiate Repeated Start condition
    while(SSPCON2bits.RSEN);     // Wait for Repeated Start to complete
    PIR1bits.SSPIF = 0;          // Clear SSP interrupt flag after repeated start
} 
void I2C_Write(unsigned char data) {
    
    SSPBUF = data;               // Load the data to SSPBUF register (start transmission)
    while(SSPSTATbits.BF);       // Wait until the Buffer Full (BF) flag is cleared
    while(SSPCON2bits.ACKSTAT);  // Wait for acknowledgment from slave (ACKSTAT = 0 if ACK received)
    PIR1bits.SSPIF = 0;          // Clear SSP interrupt flag after transmission
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
}
unsigned char I2C_Read(void) {
   
  
    SSPCON2bits.RCEN = 1;        // Enable receive mode (start reception)
    while(!SSPSTATbits.BF);      // Wait until Buffer Full flag is set (data received)
    
    PIR1bits.SSPIF = 0;          // Clear SSP interrupt flag after reception
    
    return SSPBUF;               // Read and return the received data
    
} 
void I2C_Acknowledge(unsigned char ack_type) {
    
    
    SSPCON2bits.ACKDT = ack_type; // 0: Acknowledge, 1: Not Acknowledge
    SSPCON2bits.ACKEN = 1;        // Send the ACK/NACK
    while(SSPCON2bits.ACKEN);     // Wait for the ACK sequence to complete
    PIR1bits.SSPIF = 0;           // Clear SSP interrupt flag after acknowledge
    
} 
void I2C_Stop(void) {
   
    
    SSPCON2bits.PEN = 1;         // Initiate Stop condition
    while(SSPCON2bits.PEN);      // Wait for Stop condition to complete
    PIR1bits.SSPIF = 0;          // Clear SSP interrupt flag after stop condition
    
}
void EEPROM_Write(unsigned char address, unsigned char data) {
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("EEPROM_Address");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    I2C_Start();                // Send Start condition
    I2C_Write(0xA0);            // Send EEPROM address with write operation (0xA0)
    Lcd_Set_Cursor(2, 1);
    Lcd_Display_Hex(0xA0);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("REGISTER_Address");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Display_Hex(address);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    I2C_Write(address);         // Send the memory address where data is to be written
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("EEPROM_DATA");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Display_Hex(data);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    I2C_Write(data);            // Send the data byte to write
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    
    I2C_Stop();                 // Send Stop condition
    __delay_ms(1000);
}
unsigned char EEPROM_Read(unsigned char address) {
    unsigned char data;
    
    I2C_Start();                // Send Start condition
    I2C_Write(0xA0);            // Send EEPROM address with write operation (0xA0)
    
    I2C_Write(address);         // Send the memory address to read from
    
    
    I2C_RepeatedStart();        // Send Repeated Start condition
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("READING_EEPROM");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Display_Hex(0XA1);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    
    I2C_Write(0xA1);  
    Lcd_Clear();
    Lcd_Set_Cursor(1, 1);  // Set cursor to first row, first column
    Lcd_Write_String("FROM_REGISTER");
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    Lcd_Set_Cursor(2, 1);
    Lcd_Display_Hex(address);
    for (int i = 0; i < 5; i++) {
        __delay_ms(1000);  // Delay for 1000ms (1 second)
    }
    
    data = I2C_Read();          // Read the data from the specified memory address
    I2C_Acknowledge(0);         // Send NACK to end the read operation
    __delay_ms(1000);
    I2C_Stop();                 // Send Stop condition
    __delay_ms(1000);
    return data;                // Return the read data
}
// LCD initialization function
void Lcd_Init(void) {
    Lcd_Cmd(0x38);  // Set LCD to 8-bit mode, 2 lines, 5x7 matrix
 
    
    Lcd_Cmd(0x0C);  // Display ON, Cursor OFF
    Lcd_Cmd(0x06);  // Auto Increment cursor
    Lcd_Cmd(0x01);  // Clear display
    __delay_ms(2);
}
// Send command to LCD
void Lcd_Cmd(unsigned char cmd) {
    Reg_selec = 0;  // RS = 0 for command
    // Send command
    D0 = (cmd >> 0) & 1; // Send bit 0
    D1 = (cmd >> 1) & 1; // Send bit 1
    D2 = (cmd >> 2) & 1; // Send bit 2
    D3 = (cmd >> 3) & 1; // Send bit 3
    D4 = (cmd >> 4) & 1; // Send bit 4
    D5 = (cmd >> 5) & 1; // Send bit 5
    D6 = (cmd >> 6) & 1; // Send bit 6
    D7 = (cmd >> 7) & 1; // Send bit 7
    Enable = 1;  // Enable pulse
    __delay_ms(1);
    Enable = 0;  // Disable pulse
}
// Clear LCD screen
void Lcd_Clear(void) {
    Lcd_Cmd(0x01);  // Clear display
    __delay_ms(2);
}
// Set cursor position
void Lcd_Set_Cursor(unsigned char row, unsigned char col) {
    unsigned char temp;
    if(row == 1) {
        temp = 0x80 + col - 1;  // Set cursor to row 1
    } else if(row == 2) {
        temp = 0xC0 + col - 1;  // Set cursor to row 2
    }
    Lcd_Cmd(temp);  // Send command to move cursor
    __delay_ms(2);
}
// Write a character to the LCD
void Lcd_Write_Char(char data) {
    Reg_selec = 1;  // RS = 1 for data
    D0 = (data >> 0) & 1; // Send bit 0
    D1 = (data >> 1) & 1; // Send bit 1
    D2 = (data >> 2) & 1; // Send bit 2
    D3 = (data >> 3) & 1; // Send bit 3
    D4 = (data >> 4) & 1; // Send bit 4
    D5 = (data >> 5) & 1; // Send bit 5
    D6 = (data >> 6) & 1; // Send bit 6
    D7 = (data >> 7) & 1; // Send bit 7
    Enable = 1;  // Enable pulse
    __delay_ms(1);
    Enable = 0;  // Disable pulse
}
// Write a string to the LCD
void Lcd_Write_String(char* str) {
    while (*str) {
        Lcd_Write_Char(*str++);
    }
}
void Lcd_Display_Hex(unsigned char hex_value) {
    char hex_digits[] = "0123456789ABCDEF";  // Array of hex characters

    // Extract the high nibble (upper 4 bits) and low nibble (lower 4 bits)
    char high_nibble = (hex_value >> 4) & 0x0F;  // Shift right by 4 bits and mask lower 4 bits
    char low_nibble = hex_value & 0x0F;          // Mask the lower 4 bits

    // Display '0x' prefix (optional)
    Lcd_Write_Char('0');
    Lcd_Write_Char('x');

    // Display the high nibble (most significant digit)
    Lcd_Write_Char(hex_digits[high_nibble]);

    // Display the low nibble (least significant digit)
    Lcd_Write_Char(hex_digits[low_nibble]);
}
